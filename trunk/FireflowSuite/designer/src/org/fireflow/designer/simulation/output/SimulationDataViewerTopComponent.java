/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.fireflow.designer.simulation.output;

import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import org.fireflow.designer.simulation.FireflowSimulationWorkspace;
import org.fireflow.designer.simulation.engine.persistence.IStorageChangeListener;
import org.fireflow.designer.simulation.engine.persistence.MemoryPersistenceService;
import org.fireflow.designer.simulation.engine.persistence.StorageChangedEvent;
import org.fireflow.engine.EngineException;
import org.fireflow.engine.IProcessInstance;
import org.fireflow.engine.ITaskInstance;
import org.fireflow.engine.IWorkItem;
import org.fireflow.engine.impl.ProcessInstance;
import org.fireflow.engine.impl.TaskInstance;
import org.fireflow.engine.impl.WorkItem;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle;
import org.openide.windows.Mode;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
//import org.openide.util.Utilities;
/**
 * Top component which displays something.
 */
public final class SimulationDataViewerTopComponent extends TopComponent implements IStorageChangeListener {

    private static SimulationDataViewerTopComponent instance;
    private MemoryPersistenceService persistenceService = null;
    private JTable processInstanceTable = new JTable();
    private JTable taskInstanceTable = new JTable();
    private JTable workItemTable = new JTable();
    private JTable variableTable = new JTable();
    /** path to the icon used by the component and its open action */
//    static final String ICON_PATH = "SET/PATH/TO/ICON/HERE";
    private static final String PREFERRED_ID = "SimulationDataViewerTopComponent";

    private SimulationDataViewerTopComponent() {
        initComponents();
        setName(NbBundle.getMessage(SimulationDataViewerTopComponent.class, "CTL_SimulationDataViewerTopComponent"));
        setToolTipText(NbBundle.getMessage(SimulationDataViewerTopComponent.class, "HINT_SimulationDataViewerTopComponent"));
        myInitComponents();

        MemoryPersistenceService persistenceService = (MemoryPersistenceService) FireflowSimulationWorkspace.beanFactory.getBean("persistenceService");
        this.setMemoryPersistenceService(persistenceService);

    }

    private void myInitComponents() {
        this.mainTabbedPanel.add("Process Instance", new JScrollPane(processInstanceTable));
        this.mainTabbedPanel.add("Task Instance", new JScrollPane(taskInstanceTable));
        this.mainTabbedPanel.add("Work Item", new JScrollPane(workItemTable));
        this.mainTabbedPanel.add("Workflow Variable", new JScrollPane(variableTable));
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainTabbedPanel = new javax.swing.JTabbedPane();

        setName("mainTabbedPanel"); // NOI18N
        setLayout(new java.awt.BorderLayout());
        add(mainTabbedPanel, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTabbedPane mainTabbedPanel;
    // End of variables declaration//GEN-END:variables
    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link findInstance}.
     */
    public static synchronized SimulationDataViewerTopComponent getDefault() {
        if (instance == null) {
            instance = new SimulationDataViewerTopComponent();
        }
        return instance;
    }

    /**
     * Obtain the SimulationDataViewerTopComponent instance. Never call {@link #getDefault} directly!
     */
    public static synchronized SimulationDataViewerTopComponent findInstance() {
        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
        if (win == null) {
            Logger.getLogger(SimulationDataViewerTopComponent.class.getName()).warning(
                    "Cannot find " + PREFERRED_ID + " component. It will not be located properly in the window system.");
            return getDefault();
        }
        if (win instanceof SimulationDataViewerTopComponent) {
            return (SimulationDataViewerTopComponent) win;
        }
        Logger.getLogger(SimulationDataViewerTopComponent.class.getName()).warning(
                "There seem to be multiple components with the '" + PREFERRED_ID +
                "' ID. That is a potential source of errors and unexpected behavior.");
        return getDefault();
    }

    @Override
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_ALWAYS;
    }

    @Override
    public void componentOpened() {
    // TODO add custom code on component opening
    }

    @Override
    public void componentClosed() {
    // TODO add custom code on component closing
    }

    @Override
    public void open() {
        Mode m = WindowManager.getDefault().findMode("output");
        if (m != null) {
            m.dockInto(instance);
        }
        super.open();
    }

    /** replaces this in object stream */
    @Override
    public Object writeReplace() {
        return new ResolvableHelper();
    }

    @Override
    protected String preferredID() {
        return PREFERRED_ID;
    }

    final static class ResolvableHelper implements Serializable {

        private static final long serialVersionUID = 1L;

        public Object readResolve() {
            return SimulationDataViewerTopComponent.getDefault();
        }
    }

    public void onStorageChanged(StorageChangedEvent e) {
        taskInstanceTable.revalidate();
        taskInstanceTable.repaint();
        workItemTable.revalidate();
        processInstanceTable.revalidate();
        processInstanceTable.repaint();

        List vList = new ArrayList();
        Map processInstanceStorage = persistenceService.getProcessInstanceStorage();
        Object[] processInstanceArr = processInstanceStorage.values().toArray();
        for (int i = 0; processInstanceArr != null && i < processInstanceArr.length; i++) {
            IProcessInstance processInstance = (IProcessInstance) processInstanceArr[i];
            Map variables = processInstance.getProcessInstanceVariables();
            Iterator keyIter = variables.keySet().iterator();
            while (keyIter.hasNext()) {
                String name = (String) keyIter.next();
                Object value = variables.get(name);
                ProcessInstanceVariable4Simulation v = new ProcessInstanceVariable4Simulation(processInstance, name, value);
                vList.add(v);
            }
        }
        VariableTableModel vTableModel = new VariableTableModel(vList);
        variableTable.setModel(vTableModel);
        variableTable.revalidate();
        variableTable.repaint();
        this.repaint();

    }

    public void setMemoryPersistenceService(MemoryPersistenceService psrvc) {
        persistenceService = psrvc;

        persistenceService.removeStorageChangeListener(this);
        persistenceService.addStorageChangeListenser(this);

        showStorageData();
    }

    private void showStorageData() {
        ProcessInstanceTableModel processInstanceModel = new ProcessInstanceTableModel(persistenceService.getProcessInstanceStorage());
        this.processInstanceTable.setModel(processInstanceModel);

        TaskInstanceTableModel taskInstanceModel = new TaskInstanceTableModel(persistenceService.getTaskInstanceStorage());
        this.taskInstanceTable.setModel(taskInstanceModel);

        WorkItemTableModel workItemModel = new WorkItemTableModel(persistenceService.getWorkItemStorage());
        this.workItemTable.setModel(workItemModel);


    }
}

class ProcessInstanceTableModel extends AbstractTableModel {

    private static final String[] columnNames = new String[]{"Id", "Display Name", "Name", "State", "Parent Process Instance Id"};
    Map processInstanceStorage = null;

    public ProcessInstanceTableModel(Map storage) {
        processInstanceStorage = storage;

    }

    @Override
    public String getColumnName(int columnIndex) {
        return columnNames[columnIndex];
    }

    public int getRowCount() {

        if (processInstanceStorage == null) {
            return 0;
        }
//        System.out.println("======++++storage size is "+processInstanceStorage.size());
        return processInstanceStorage.size();
    }

    public int getColumnCount() {
        return 5;
    }

    public Object getValueAt(int rowIndex, int columnIndex) {
        Object[] processInstanceStorageArr = processInstanceStorage.values().toArray();
        ProcessInstance procInst = (ProcessInstance) processInstanceStorageArr[rowIndex];
        switch (columnIndex) {
            case 0:
                return procInst.getId();

            case 1:
                return procInst.getDisplayName();

            case 2:
                return procInst.getName();

            case 3:
                if (procInst.getState()==IProcessInstance.INITIALIZED){
                    return "已初始化";
                }else if (procInst.getState()==IProcessInstance.STARTED){
                    return "运行中";
                }else if (procInst.getState()==IProcessInstance.COMPLETED){
                    return "已结束";
                }else if (procInst.getState()==IProcessInstance.CANCELED){
                    return "被取消";
                }
                return procInst.getState();

            case 4:
                return procInst.getParentProcessInstanceId();
            default:
                return "";
        }
    }
}

class TaskInstanceTableModel extends AbstractTableModel {

    private static final String[] columnNames = new String[]{"Id", "Display Name", "Name",
        "State", "Task Id", "Activity Id", "Task Type", "Completion Strategy", "Create Time",
        "Start Time", "Expired Time", "End Time"
    };
    Map taskInstanceStorage = null;

    public TaskInstanceTableModel(Map storage) {
        taskInstanceStorage = storage;
    }

    @Override
    public String getColumnName(int columnIndex) {
        return columnNames[columnIndex];
    }

    public int getRowCount() {

        if (taskInstanceStorage == null) {
            return 0;
        }

        return taskInstanceStorage.size();
    }

    public int getColumnCount() {
        return 12;
    }

    public Object getValueAt(int rowIndex, int columnIndex) {
        SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm");
        Object[] processInstanceStorageArr = taskInstanceStorage.values().toArray();
        TaskInstance taskInst = (TaskInstance) processInstanceStorageArr[rowIndex];
        switch (columnIndex) {
            case 0:
                return taskInst.getId();

            case 1:
                return taskInst.getDisplayName();

            case 2:
                return taskInst.getName();

            case 3:
                if (taskInst.getState()==ITaskInstance.INITIALIZED){
                    return "已初始化";
                }else if (taskInst.getState()==ITaskInstance.STARTED){
                    return "运行中";
                }else if (taskInst.getState()==ITaskInstance.COMPLETED){
                    return "已结束";
                }else if (taskInst.getState()==ITaskInstance.CANCELED){
                    return "被取消";
                }                
                return taskInst.getState();

            case 4:
                return taskInst.getTaskId();

            case 5:
                return taskInst.getActivityId();

            case 6:
                return taskInst.getTaskType();
            case 7:
                return taskInst.getCompletionStrategy();

            case 8:
                if (taskInst.getCreatedTime()!=null){
                    return dFormat.format(taskInst.getCreatedTime());
                }else{
                    return "";
                }

            case 9:
                if (taskInst.getStartedTime()!=null){
                    return dFormat.format(taskInst.getStartedTime());
                }else{
                    return "";
                }                

            case 10:
                if (taskInst.getExpiredTime()!=null){
                    return dFormat.format(taskInst.getExpiredTime());
                }else{
                    return "";
                }                  

            case 11:
                if (taskInst.getEndTime()!=null){
                    return dFormat.format(taskInst.getEndTime());
                }else{
                    return "";
                }                  

            default:
                return "";
        }
    }
}

class WorkItemTableModel extends AbstractTableModel {

    private static final String[] columnNames = new String[]{"Id", "State", "Create Time", "Signed Time", "End Time", "Actor Id", "Comments"};
    Map workItemStorage = null;

    public WorkItemTableModel(Map storage) {
        workItemStorage = storage;
    }

    @Override
    public String getColumnName(int columnIndex) {
        return columnNames[columnIndex];
    }

    public int getRowCount() {

        if (workItemStorage == null) {
            return 0;
        }

        return workItemStorage.size();
    }

    public int getColumnCount() {
        return 7;
    }

    public Object getValueAt(int rowIndex, int columnIndex) {
        SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm");
        Object[] processInstanceStorageArr = workItemStorage.values().toArray();
        WorkItem workItem = (WorkItem) processInstanceStorageArr[rowIndex];
        switch (columnIndex) {
            case 0:
                return workItem.getId();

            case 1:
                if (workItem.getState()==IWorkItem.INITIALIZED){
                    return "已初始化";
                }else if (workItem.getState()==IWorkItem.STARTED){
                    return "运行中";
                }else if (workItem.getState()==IWorkItem.COMPLETED){
                    return "已结束";
                }else if (workItem.getState()==IWorkItem.CANCELED){
                    return "被取消";
                }                   
                return workItem.getState();

            case 2:
                if (workItem.getCreatedTime()!=null){
                    return dFormat.format(workItem.getCreatedTime());
                }else{
                    return "";
                }                 

            case 3:
                if (workItem.getAcceptedTime()!=null){
                    return dFormat.format(workItem.getAcceptedTime());
                }else{
                    return "";
                }                   

            case 4:
                if (workItem.getEndTime()!=null){
                    return dFormat.format(workItem.getEndTime());
                }else{
                    return "";
                }                   

            case 5:
                return workItem.getActorId();

            case 6:
                return workItem.getComments();
            default:
                return "";
        }
    }
}

class VariableTableModel extends AbstractTableModel {

    private static final String[] columnNames = new String[]{"Process DisplayName", "Name", "Type", "Value"};
    List varList = null;

    public VariableTableModel(List varList) {
        this.varList = varList;
    }

    @Override
    public String getColumnName(int columnIndex) {
        return columnNames[columnIndex];
    }

    public int getRowCount() {

        if (varList == null) {
            return 0;
        }

        return varList.size();
    }

    public int getColumnCount() {
        return columnNames.length;
    }

    public Object getValueAt(int rowIndex, int columnIndex) {

        ProcessInstanceVariable4Simulation var = (ProcessInstanceVariable4Simulation) varList.get(rowIndex);
        switch (columnIndex) {
            case 0:
                return var.getProcessDisplayName();

            case 1:
                return var.getName();

            case 2:
                return var.getType();

            case 3:
                return var.getValue();
            default:
                return "";
        }
    }
}

class ProcessInstanceVariable4Simulation {

    String processDisplayName = null;
    String name = null;
    String type = null;
    String value = null;

    public ProcessInstanceVariable4Simulation(IProcessInstance processInstance, String name, Object value) {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        try {
            processDisplayName = processInstance.getWorkflowProcess().getDisplayName();
        } catch (EngineException ex) {
            Exceptions.printStackTrace(ex);
        }
        this.name = name;
        if (value != null) {
            if (value instanceof Integer) {
                type = "Integer";
                this.value = value.toString();
            } else if (value instanceof Float) {
                type = "Float";
                this.value = value.toString();
            } else if (value instanceof Boolean) {
                type = "Boolean";
                this.value = value.toString();
            } else if (value instanceof Date) {
                type = "Date";
                this.value = format.format((Date) value);
            } else {
                type = "String";
                this.value = value.toString();
            }
        } else {
            type = "String";
        }
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    public String getValue() {
        return value;
    }

    public String getProcessDisplayName() {
        return this.processDisplayName;
    }
}
