/**
 * Copyright 2007-2008 非也
 * All rights reserved. 
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation。
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses. *
 */
package org.fireflow.engine.impl;

// Generated Feb 23, 2008 12:04:21 AM by Hibernate Tools 3.2.0.b9
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.fireflow.engine.EngineException;
import org.fireflow.engine.IRuntimeContextAware;
import org.fireflow.engine.ITaskInstance;
import org.fireflow.engine.IWorkItem;
import org.fireflow.engine.IWorkflowSession;
import org.fireflow.engine.IWorkflowSessionAware;
import org.fireflow.engine.RuntimeContext;
import org.fireflow.engine.ou.DynamicAssignmentHandler;
import org.fireflow.engine.persistence.IPersistenceService;
import org.fireflow.kenel.IActivityInstance;
import org.fireflow.kenel.INetInstance;
import org.fireflow.kenel.KenelException;
import org.fireflow.model.Task;
import org.fireflow.model.WorkflowProcess;
import org.fireflow.model.net.Activity;
import org.fireflow.model.net.Synchronizer;
import org.fireflow.model.net.Transition;
import org.springframework.beans.BeanUtils;

/**
 * WorkItem generated by hbm2java
 */
public class WorkItem implements IWorkItem, IRuntimeContextAware, IWorkflowSessionAware,java.io.Serializable {

    private String actorId;
    private String id;
    private Integer state = null;
    private Date createdTime;
    private Date signedTime;
    private Date endTime;
    private String comments;
    private ITaskInstance taskInstance;

    protected RuntimeContext rtCtx = null;
    protected IWorkflowSession workflowSession = null;
    public void setRuntimeContext(RuntimeContext ctx){
        this.rtCtx = ctx;
    }    
    public RuntimeContext getRuntimeContext(){
        return this.rtCtx;
    }     
    public WorkItem() {
    }

    public WorkItem(TaskInstance taskInstance) {
        this.taskInstance = taskInstance;
    }

    public WorkItem(Integer state, Date createdTime, Date signedTm,
            Date endTime, String comments, TaskInstance taskInstance) {
        this.state = state;
        this.createdTime = createdTime;
        this.signedTime = signedTm;
        this.endTime = endTime;
        this.comments = comments;
        this.taskInstance = taskInstance;
    }

    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public Integer getState() {
        return this.state;
    }

    public void setState(Integer state) {
        this.state = state;
    }

    public Date getCreatedTime() {
        return this.createdTime;
    }

    public void setCreatedTime(Date createdTime) {
        this.createdTime = createdTime;
    }

    public Date getSignedTime() {
        return this.signedTime;
    }

    public void setSignedTime(Date acceptedTime) {
        this.signedTime = acceptedTime;
    }

    public Date getEndTime() {
        return this.endTime;
    }

    public void setEndTime(Date endTime) {
        this.endTime = endTime;
    }

    public String getComments() {
        return this.comments;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }

    public ITaskInstance getTaskInstance() {
        if (this.taskInstance!=null){
            ((IRuntimeContextAware)this.taskInstance).setRuntimeContext(rtCtx);
//            System.out.println("====Inside WorkItem.getTaskInstance() ,the workflow session is "+(this.workflowSession==null?0:this.workflowSession.hashCode()));
            if (this.workflowSession!=null){
                ((IWorkflowSessionAware)this.taskInstance).setCurrentWorkflowSession(this.workflowSession);
            }
        }
        return this.taskInstance;
    }

    public void setTaskInstance(ITaskInstance taskInstance) {
        this.taskInstance = taskInstance;
    }

    public String getActorId() {
        return actorId;
    }

    public void setActorId(String actorId) {
        this.actorId = actorId;
    }
    
    public void complete() throws EngineException, KenelException {
        complete(null);
    }

    protected void complete(IActivityInstance targetActivityInstance) throws EngineException, KenelException {
        if (this.getState().intValue() != IWorkItem.STARTED) {
//			System.out.println("WorkItem的当前状态为"+this.getState()+"，不可以执行complete操作。");
            throw new EngineException("WorkItem的当前状态为" + this.getState() + "，不可以执行complete操作。");
        }
        
        IPersistenceService persistenceService = rtCtx.getPersistenceService();

        this.setState(IWorkItem.COMPLETED);
        this.setEndTime(rtCtx.getCalendarService().getSysDate());
        persistenceService.saveOrUpdateWorkItem(this);

        ((TaskInstance) this.getTaskInstance()).complete(targetActivityInstance);
    }




    public void reasignTo(String actorId) {
        reasignTo(actorId,comments);
    }
    

    public void reasignTo(String actorId,String comments){
        WorkItem wi = new WorkItem();
        BeanUtils.copyProperties(this, wi);
        wi.setActorId(actorId);
        wi.setComments(comments);
        wi.setCreatedTime(rtCtx.getCalendarService().getSysDate());
        rtCtx.getPersistenceService().saveOrUpdateWorkItem(wi);
        
        this.setState(IWorkItem.CANCELED);
        this.setEndTime(rtCtx.getCalendarService().getSysDate());
        rtCtx.getPersistenceService().saveOrUpdateWorkItem(this);
    }

    /**
     * 签收
     * @throws org.fireflow.engine.EngineException
     * @throws org.fireflow.kenel.KenelException
     */
    public void sign() throws EngineException, KenelException {

        if (this.getState().intValue() != IWorkItem.INITIALIZED) {
            throw new EngineException("WorkItem的当前状态为" + this.getState() + "，不可以执行accept操作。");
        }
        if (this.getTaskInstance().getState().intValue() != ITaskInstance.INITIALIZED && this.getTaskInstance().getState().intValue() != ITaskInstance.STARTED) {
            throw new EngineException("TaskInstance的当前状态为" + this.getTaskInstance().getState() + "，对应的WorkItem不可以执行accept操作。");
        }
      
        IPersistenceService persistenceService = rtCtx.getPersistenceService();

        //0、首先修改workitem的状态
        this.setState(IWorkItem.STARTED);
        this.setSignedTime(rtCtx.getCalendarService().getSysDate());
        persistenceService.saveOrUpdateWorkItem(this);

        //1、如果不是会签，则删除其他的workitem
        if (Task.ANY.equals(this.getTaskInstance().getAssignmentStrategy())){
            persistenceService.deleteWorkItemsInInitializedState(this.getTaskInstance().getId());
        }
        
        //2、start taskInstance,修改相关联的workItem的状态。
        ((TaskInstance) this.getTaskInstance()).start();

    }

    public void junpToNextActivity(List<String> nextActorIds) throws EngineException, KenelException {
        junpToNextActivity(nextActorIds,false);
    }

    public void jumpTo(String activityId) throws EngineException, KenelException {
        jumpTo(activityId,null,true);
    }

    public void jumpTo(String activityId, List<String> nextActorIds) throws EngineException, KenelException {
        jumpTo(activityId,nextActorIds,false);
    }

    public void loopTo(String activityId) throws EngineException, KenelException {
        //首先找到上次的执行者，如果上次操作是汇签，怎么办？？？？？
        
        IPersistenceService persistenceService = rtCtx.getPersistenceService();
        List taskInstanceList = persistenceService.findTaskInstancesForProcessInstance(this.getTaskInstance().getProcessInstanceId(), activityId);
        if (taskInstanceList==null && taskInstanceList.size()==0){
            throw new EngineException("The activity has NOT been fired yet.");
        }
        TaskInstance tmpTaskInstance = (TaskInstance)taskInstanceList.get(0);
        if (tmpTaskInstance.getState()!=ITaskInstance.COMPLETED && tmpTaskInstance.getState()!=ITaskInstance.CANCELED){
            throw new EngineException("The activity instance is in running state.");
        }
        for (int i=1;i<taskInstanceList.size();i++){
            
            TaskInstance tmpTaskInst2 = (TaskInstance)taskInstanceList.get(i);
            if (tmpTaskInst2.getState()!=ITaskInstance.COMPLETED && tmpTaskInst2.getState()!=ITaskInstance.CANCELED){
                throw new EngineException("The activity instance is in running state.");
            }            
            if (tmpTaskInst2.getCreatedTime().after(tmpTaskInstance.getCreatedTime())){
                tmpTaskInstance = tmpTaskInst2;
            }
        }
        
        List workItems = persistenceService.findWorkItemsForTaskInstance(tmpTaskInstance.getId());
        if (workItems==null || workItems.size()==0) throw new EngineException("LoopTo action refused, have-done workitems for activity[id="+activityId+"] NOT found");
        
        List nextActorIds = new ArrayList();
        for (int i=0;i<workItems.size();i++){
            nextActorIds.add(((IWorkItem)workItems.get(i)).getActorId());
        }
        this.jumpTo(activityId,nextActorIds,false);
        /*
        List workItems = persistenceService.findHaveDoneWorkItems(this.getTaskInstance().getProcessInstance().getId(), activityId);
        
        if (workItems==null || workItems.size()==0) throw new EngineException("Not found have done workitems for activity[id="+activityId+"]");
        */
        
                
    }
    public IWorkflowSession getCurrentWorkflowSession() {
        return this.workflowSession;
    }

    public void setCurrentWorkflowSession(IWorkflowSession session) {
        this.workflowSession = session;
    }

    public void junpToNextActivity(List<String> nextActorIds, boolean needSign) throws EngineException, KenelException {
        WorkflowProcess workflowProcess = this.getTaskInstance().getWorkflowProcess();
        Activity thisActivity = this.getTaskInstance().getActivity();
        Transition leavingTransition = thisActivity.getLeavingTransition();
        if (leavingTransition==null) throw new EngineException("Next activity NOT found.");
        Synchronizer synchronizer = (Synchronizer)leavingTransition.getToNode();
        if (synchronizer==null) throw new EngineException("Next activity NOT found.");
        List leavingTransitionList = synchronizer.getLeavingTransitions();
        if (leavingTransitionList==null || leavingTransitionList.size()==0) throw new EngineException("Next activity NOT found.");
        
        leavingTransition = (Transition)leavingTransitionList.get(0);
        Activity targetActivity = (Activity)leavingTransition.getToNode();
        
        if (targetActivity==null){
            throw new EngineException("Next activity NOT found.");
        }
        
        jumpTo(targetActivity.getId(),nextActorIds,needSign);
    }

    public void jumpTo(String activityId, List<String> nextActorIds, boolean needSign) throws EngineException, KenelException {
        //首先检查是否可以正确跳转
        //1）检查是否在同一个“执行线”上
        WorkflowProcess workflowProcess = this.getTaskInstance().getWorkflowProcess();
        String thisActivityId = this.getTaskInstance().getActivityId();
        boolean isInSameLine = workflowProcess.isInSameLine(thisActivityId, activityId);
        if (!isInSameLine) throw new EngineException("Jumpto refused because of the current activitgy and the target activity are NOT in the same 'Execution Thread'.");
        
        
        //2）检查目标Activity Form Task的数量(暂时关闭该检查项目)
//        Activity targetActivity = (Activity)workflowProcess.findWFElementById(activityId);
//        int count = getFormTaskCount(targetActivity);
//        if (count!=1){
//            if (!isInSameLine) throw new EngineException("Jumpto refused because of the  FORM-type-task count of the target activitgy  is NOT 1; the count is "+count);
//        }
        
        //3)检查当前的 taskinstance是否可以结束
        if (Task.ALL.equals(this.getTaskInstance().getAssignmentStrategy())){
            IPersistenceService persistenceService = rtCtx.getPersistenceService();
            List workItemList = persistenceService.findWorkItemsForTaskInstance(this.getTaskInstance().getId());
            for (int i=0;workItemList!=null && i<workItemList.size();i++){
                IWorkItem wi = (IWorkItem)workItemList.get(i);
                if (!wi.getId().equals(this.id) && (wi.getState()!=IWorkItem.COMPLETED || wi.getState()!=IWorkItem.CANCELED)){
                    throw new EngineException("Jumpto refused because of current taskinstance can NOT be completed. some workitem of this taskinstance is in runing state or initialized state");
                }
            }
        }

        //4)检查当前的activity instance是否可以结束

        if (Activity.ALL .equals(this.getTaskInstance().getActivity().getCompletionStrategy())){
            IPersistenceService persistenceService = rtCtx.getPersistenceService();
            List taskinstanceList = persistenceService.findTaskInstancesForProcessInstance(this.getTaskInstance().getProcessInstanceId(), this.getTaskInstance().getActivityId());
            
            for (int i=0;i<taskinstanceList.size();i++){
                TaskInstance taskInst = (TaskInstance)taskinstanceList.get(i);
                if (!taskInst.getId().equals(this.getTaskInstance().getId()) 
                        && (taskInst.getState()!=ITaskInstance.COMPLETED || taskInst.getState()!=ITaskInstance.CANCELED)){
                    throw new EngineException("Jumpto refused because of current activity instance can NOT be completed. some task instance of this activity instance is in runing state or initialized state");
                }
            }
        }
        
//        this.getTaskInstance().geta
        INetInstance netInstance = rtCtx.getKenelManager().getNetInstance(workflowProcess.getId(), this.getTaskInstance().getVersion());
        if (netInstance==null) throw new EngineException("Not find the net instance for workflow process [id="+workflowProcess.getId()+", version="+ this.getTaskInstance().getVersion()+"]");
        Object obj = netInstance.getWFElementInstance(activityId);
        IActivityInstance targetActivityInstance = (IActivityInstance)obj;
        if (targetActivityInstance==null){
             throw new EngineException("Not find the activity instance  for activity[process id="+workflowProcess.getId()+", version="+ this.getTaskInstance().getVersion()+",activity id="+activityId+"]");
        }

        if (nextActorIds!=null && nextActorIds.size()>0){
            DynamicAssignmentHandler handler = new DynamicAssignmentHandler();
            handler.setActorIdsList(nextActorIds);
            handler.setNeedSign(needSign);
            ((WorkflowSession)this.workflowSession).setCurrentDynamicAssignmentHandler(handler);
        }else{
            ((WorkflowSession)this.workflowSession).setCurrentDynamicAssignmentHandler(null);
        }
        
        this.complete(targetActivityInstance);
    }
    
    protected int getFormTaskCount(Activity activity){
        int count = 0;
        List tasksList = activity.getTasks();
        for (int i=0;i<tasksList.size();i++){
            Task task = (Task)tasksList.get(i);
            if (Task.FORM.equals(task.getType())){
                count = count+1;
            }
        }
        return count;
    }
}
