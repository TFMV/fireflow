/**
 * Copyright 2007-2008 非也
 * All rights reserved. 
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation。
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses. *
 */
package org.fireflow.engine.impl;

// Generated Feb 23, 2008 12:04:21 AM by Hibernate Tools 3.2.0.b9
import java.util.Date;
import java.util.List;

import org.fireflow.engine.EngineException;
import org.fireflow.engine.IRuntimeContextAware;
import org.fireflow.engine.ITaskInstance;
import org.fireflow.engine.IWorkItem;
import org.fireflow.engine.IWorkflowSession;
import org.fireflow.engine.IWorkflowSessionAware;
import org.fireflow.engine.RuntimeContext;
import org.fireflow.engine.taskinstance.ITaskInstanceManager;
import org.fireflow.kernel.IActivityInstance;
import org.fireflow.kernel.KernelException;
import org.fireflow.model.Task;
import org.fireflow.model.net.Activity;
import org.fireflow.model.net.Synchronizer;
import org.fireflow.model.net.Transition;

/**
 * WorkItem generated by hbm2java
 */
public class WorkItem implements IWorkItem, IRuntimeContextAware, IWorkflowSessionAware, java.io.Serializable {

    private String actorId;
    private String id;
    private Integer state = null;
    private Date createdTime;
    /**
     * 签收时间
     */
    private Date claimedTime;
    private Date endTime;
    private String comments;
    private ITaskInstance taskInstance;
    protected RuntimeContext rtCtx = null;
    protected IWorkflowSession workflowSession = null;

    public void setRuntimeContext(RuntimeContext ctx) {
        this.rtCtx = ctx;
    }

    public RuntimeContext getRuntimeContext() {
        return this.rtCtx;
    }

    public WorkItem() {
    }

    public WorkItem(TaskInstance taskInstance) {
        this.taskInstance = taskInstance;
    }

    public WorkItem(Integer state, Date createdTime, Date signedTm,
            Date endTime, String comments, TaskInstance taskInstance) {
        this.state = state;
        this.createdTime = createdTime;
        this.claimedTime = signedTm;
        this.endTime = endTime;
        this.comments = comments;
        this.taskInstance = taskInstance;
    }

    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public Integer getState() {
        return this.state;
    }

    public void setState(Integer state) {
        this.state = state;
    }

    public Date getCreatedTime() {
        return this.createdTime;
    }

    public void setCreatedTime(Date createdTime) {
        this.createdTime = createdTime;
    }

    /**
     * @deprecated 
     * @return
     */
    public Date getSignedTime() {
        return this.claimedTime;
    }

    public Date getClaimedTime() {
        return this.claimedTime;
    }

    /**
     * @deprecated
     * @param acceptedTime
     */
    public void setSignedTime(Date claimedTime) {
        this.claimedTime = claimedTime;
    }

    public void setClaimedTime(Date claimedTime) {
        this.claimedTime = claimedTime;
    }

    public Date getEndTime() {
        return this.endTime;
    }

    public void setEndTime(Date endTime) {
        this.endTime = endTime;
    }

    public String getComments() {
        return this.comments;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }

    public ITaskInstance getTaskInstance() {
        if (this.taskInstance != null) {
            ((IRuntimeContextAware) this.taskInstance).setRuntimeContext(rtCtx);
//            System.out.println("====Inside WorkItem.getTaskInstance() ,the workflow session is "+(this.workflowSession==null?0:this.workflowSession.hashCode()));
            if (this.workflowSession != null) {
                ((IWorkflowSessionAware) this.taskInstance).setCurrentWorkflowSession(this.workflowSession);
            }
        }
        return this.taskInstance;
    }

    public void setTaskInstance(ITaskInstance taskInstance) {
        this.taskInstance = taskInstance;
    }

    public String getActorId() {
        return actorId;
    }

    public void setActorId(String actorId) {
        this.actorId = actorId;
    }

    public IWorkItem withdraw() throws EngineException, KernelException {
        ITaskInstanceManager taskInstanceMgr = this.rtCtx.getTaskInstanceManager();
        return taskInstanceMgr.withdrawWorkItem(this);
    }


    public void reject()throws EngineException, KernelException{
        reject(this.getComments());
    }
    
    public void reject(String comments) throws EngineException, KernelException {
        ITaskInstanceManager taskInstanceMgr = this.rtCtx.getTaskInstanceManager();
        taskInstanceMgr.rejectWorkItem(this,comments);
    }
    
    public void complete() throws EngineException, KernelException {
        complete(this.getComments());
    }

    public void complete(String comments) throws EngineException, KernelException {
        complete(null,comments);
    }

    protected void complete(IActivityInstance targetActivityInstance,String comments) throws EngineException, KernelException {
        ITaskInstanceManager taskInstanceManager = this.rtCtx.getTaskInstanceManager();
        taskInstanceManager.completeWorkItem(this, targetActivityInstance,comments);
    }

    public void reasignTo(String actorId) {
        reasignTo(actorId, comments);
    }

    public IWorkItem reasignTo(String actorId, String comments) {
        ITaskInstanceManager manager = this.rtCtx.getTaskInstanceManager();
        return manager.reasignWorkItemTo(this, actorId, comments);
    }

    /**
     * @deprecated 
     * @throws org.fireflow.engine.EngineException
     * @throws org.fireflow.kenel.KenelException
     */
    public void sign() throws EngineException, KernelException {
        claim();
    }

    /**
     * 签收
     * @throws org.fireflow.engine.EngineException
     * @throws org.fireflow.kenel.KenelException
     */
    public void claim() throws EngineException, KernelException {
        ITaskInstanceManager taskInstanceMgr = rtCtx.getTaskInstanceManager();
        taskInstanceMgr.claimWorkItem(this);

    }



    public void jumpTo(String activityId) throws EngineException, KernelException {
        jumpTo(activityId, null, true);
    }

    public void jumpTo(String activityId, String comments) throws EngineException, KernelException {
        jumpTo(activityId, null, true,comments);
    }

    public void jumpTo(String activityId, List<String> nextActorIds) throws EngineException, KernelException {
        jumpTo(activityId, nextActorIds, false);
    }
    public void jumpTo(String activityId, List<String> nextActorIds, String comments) throws EngineException, KernelException {
        jumpTo(activityId, nextActorIds, false,comments);
    }
    public void jumpTo(String targetActivityId, List<String> nextActorIds, boolean needClaim) throws EngineException, KernelException {
        jumpTo(targetActivityId,nextActorIds,needClaim,this.getComments());
    }

    public void jumpTo(String targetActivityId, List<String> nextActorIds, boolean needClaim, String comments) throws EngineException, KernelException {
        ITaskInstanceManager taskInstanceManager = this.rtCtx.getTaskInstanceManager();
        taskInstanceManager.completeWorkItemAndJumpTo(this, targetActivityId, nextActorIds, needClaim,comments);
    }
    /*
     * 该方法废除，2009-03-23，完全可以用jumpTo来替代，
     * 当Task有了loopStrategy后，完全可以用jumpTo替代loopTo
     */
    /*
    public void loopTo(String targetActivityId) throws EngineException, KernelException {
    //首先找到上次的执行者，如果上次操作是汇签，怎么办？？？？？
    TaskInstance thisTaskInst = (TaskInstance) this.getTaskInstance();
    IPersistenceService persistenceService = rtCtx.getPersistenceService();
    Integer aliveTokenCount4TargetActivity = persistenceService.getAliveTokenCountForNode(this.getTaskInstance().getProcessInstanceId(), targetActivityId);
    if (aliveTokenCount4TargetActivity == 1) {
    throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
    thisTaskInst.getTaskId(), "The target activity instance is in running state.");
    } else if (aliveTokenCount4TargetActivity > 1) {
    throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
    thisTaskInst.getTaskId(), "FATAL ERROR!The alive token of the target activity instance greater than 1.");
    }

    //        List targetTaskInstanceList = persistenceService.findTaskInstancesForProcessInstance(this.getTaskInstance().getProcessInstanceId(), targetActivityId);
    //        if (targetTaskInstanceList == null && targetTaskInstanceList.size() == 0) {
    //        throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
    //        thisTaskInst.getTaskId(), "The target activity has NOT been fired yet.");
    //        }
    //        TaskInstance targetTaskInstance = (TaskInstance) targetTaskInstanceList.get(0);
    //        if (targetTaskInstance.getState() != ITaskInstance.COMPLETED && targetTaskInstance.getState() != ITaskInstance.CANCELED) {
    //        throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
    //        thisTaskInst.getTaskId(), "The target activity instance is in running state.");
    //        }
    //        for (int i = 1; i < targetTaskInstanceList.size(); i++) {
    //
    //        TaskInstance tmpTaskInst2 = (TaskInstance) targetTaskInstanceList.get(i);
    //        if (tmpTaskInst2.getState() != ITaskInstance.COMPLETED && tmpTaskInst2.getState() != ITaskInstance.CANCELED) {
    //        throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
    //        thisTaskInst.getTaskId(), "The target activity instance is in running state.");
    //        }
    //        if (tmpTaskInst2.getCreatedTime().after(targetTaskInstance.getCreatedTime())) {
    //        targetTaskInstance = tmpTaskInst2;
    //        }
    //        }


    List workItems = null;//暂时注释 20090309 persistenceService.findDeadWorkItemsWithoutJoinForTaskInstance(targetTaskInstance.getId());
    if (workItems == null || workItems.size() == 0) {
    throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
    thisTaskInst.getTaskId(), "LoopTo action refused, have-done workitems for activity[id=" + targetActivityId + "] NOT found");
    }

    List nextActorIds = new ArrayList();
    for (int i = 0; i < workItems.size(); i++) {
    nextActorIds.add(((IWorkItem) workItems.get(i)).getActorId());
    }
    this.jumpTo(targetActivityId, nextActorIds, false);

    }
     */
    public IWorkflowSession getCurrentWorkflowSession() {
        return this.workflowSession;
    }

    public void setCurrentWorkflowSession(IWorkflowSession session) {
        this.workflowSession = session;
    }
    public void jumpToNextActivity(List<String> nextActorIds) throws EngineException, KernelException {
        jumpToNextActivity(nextActorIds, false);
    }

    public void jumpToNextActivity(List<String> nextActorIds, String comments) throws EngineException, KernelException {
        jumpToNextActivity( nextActorIds, false, comments);
    }
    public void jumpToNextActivity(List<String> nextActorIds, boolean needClaim) throws EngineException, KernelException {
        jumpToNextActivity(nextActorIds,needClaim,this.getComments());
    }

    public void jumpToNextActivity(List<String> nextActorIds, boolean needClaim, String comments) throws EngineException, KernelException {
//        WorkflowProcess workflowProcess = this.getTaskInstance().getWorkflowProcess();
        Activity thisActivity = this.getTaskInstance().getActivity();
        Transition leavingTransition = thisActivity.getLeavingTransition();
        TaskInstance thisTaskInst = (TaskInstance) this.getTaskInstance();
        if (leavingTransition == null) {
            throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
                    thisTaskInst.getTaskId(), "Next activity NOT found.");
        }
        Synchronizer synchronizer = (Synchronizer) leavingTransition.getToNode();
        if (synchronizer == null) {
            throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
                    thisTaskInst.getTaskId(), "Next activity NOT found.");
        }
        List leavingTransitionList = synchronizer.getLeavingTransitions();

        //只有targetActivity和sourceActiviy在同一个执行线上才允许jump
        if (leavingTransitionList == null || leavingTransitionList.size() != 1) {
            throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
                    thisTaskInst.getTaskId(), "Jumpto next activity refused!Because of the size of next activity is not 1");
        }

        leavingTransition = (Transition) leavingTransitionList.get(0);
        Activity targetActivity = (Activity) leavingTransition.getToNode();

        if (targetActivity == null) {
            throw new EngineException(thisTaskInst.getProcessInstanceId(), thisTaskInst.getWorkflowProcess(),
                    thisTaskInst.getTaskId(), "Next activity NOT found.");
        }

        jumpTo(targetActivity.getId(), nextActorIds, needClaim,comments);
    }    



    protected int getFormTaskCount(Activity activity) {
        int count = 0;
        List tasksList = activity.getTasks();
        for (int i = 0; i < tasksList.size(); i++) {
            Task task = (Task) tasksList.get(i);
            if (Task.FORM.equals(task.getType())) {
                count = count + 1;
            }
        }
        return count;
    }
}
